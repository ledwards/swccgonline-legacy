class Post < ActiveRecord::Base
  validates_presence_of :title, :body, :user_id, :post_type_id
  
  belongs_to :user
  belongs_to :deck
  belongs_to :post_type
  has_many :comments
  
  acts_as_taggable
  ajaxful_rateable :stars => 5, :allow_update => true 
    
  def before_create
    deck = Deck.find(deck_id)
    new_deck_copy = Deck.new(deck.attributes)
    new_deck_copy.shared = true
    new_deck_copy.save
    self.deck_id = new_deck_copy.id
    deck.deck_items.each do |di|
      new_di = DeckItem.new(di.attributes)
      new_di.deck_id = new_deck_copy.id
      new_di.save
      self.deck.deck_items << new_di
    end
  end
  
  def after_create
    user = User.find(user_id)
    post_type = PostType.find(post_type_id)
    post_type.posts << self
  end
  
  def abbrv_body(a)
    a ||= 30
    abbrv = self.body.first(a)
    if self.body.length > a
      abbrv += "..."
    end
    return abbrv
  end
  
  def user_name
    self.user.display_name
  end
  
  def post_type_name_with_underscores
    self.post_type.singular_controller_name
  end
  
  # not currently used
  def self.index(post_type_name = nil, tag_name = nil, search_term = nil, sort_by = "id")
    posts = Post.find_all_by_post_type(post_type_name)
    
    if !tag_name.nil?
      posts = posts & Post.find_tagged_with(tag_name)
    end
    
    # handle search here

  end
  
  def self.find_all_by_post_type(post_type_name)
    post_type = PostType.find_by_name(post_type_name)
    Post.find(:all, :conditions => {:post_type_id => post_type.id})
  end
  
  def self.find_all_by_user(user_login)
    user = User.find_by_login(user_login)
    Post.find(:all, :conditions => {:user_id => user.id}) || []
  end
  
  def self.find_all_by_user_and_post_type(user_login, post_type_name)
    post_type = PostType.find_by_name(post_type_name)
    user = User.find_by_login(user_login)
    Post.find(:all, :conditions => {:user_id => user.id, :post_type_id => post_type.id}) || []
  end
  
  def self.blog_posts
    Post.find(:all, :conditions => {:post_type_id => 1}) || []
  end
  
  def self.articles
    Post.find(:all, :conditions => {:post_type_id => 2}) || []
  end
  
  def self.decklists
    Post.find(:all, :conditions => {:post_type_id => 3}) || []
  end
  
  def self.tournament_reports
    Post.find(:all, :conditions => {:post_type_id => 4}) || []
  end
  
  def self.top_n(n, post_type_name)
    post_type = PostType.find_by_name(post_type_name)
    posts = Post.find(:all, :conditions => {:post_type_id => post_type.id } )
    
    posts.sort_by { |p| p.rating_average }.reverse.first(n)
  end
  
  def self.n_most_recent(n, post_type_name)
    post_type = PostType.find_by_name(post_type_name)
    if post_type.nil?
      posts = Post.all
    else
      posts = Post.find(:all, :conditions => {:post_type_id => post_type.id } )
    end
    
    posts.sort_by { |p| p.created_at }.reverse.first(n)
  end
  
  def self.paged_find_tagged_with(tags, args = {})
    if tags.blank?
      paginate args
    else
      options = find_options_for_find_tagged_with(tags, :match_all => true)
      options.merge!(args)
      # The default count query generated by paginate includes COUNT(DISTINCT Posts.*) which errors, at least on mysql
      # Below we override the default select statement used to perform the count so that it becomes COUNT(DISTINCT Posts.id)
      paginate(options.merge(:count => { :select => options[:select].gsub('*', 'id') }))
    end
  end
  
  def self.top_n_blog_owners(n)
    blog_owners = Post.blog_posts.collect { |blog_post| blog_post.user }.uniq
    blog_owners.sort_by { |u| u.blog_posts.last.rating_average * u.blog_posts.length }
    return blog_owners.last(n)
  end
  
  def self.number_of_blogs
    Post.blog_posts.collect { |bp| bp.user }.uniq.length
  end
end
